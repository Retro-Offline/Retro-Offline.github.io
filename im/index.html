<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Image to Minecraft JSON</title>
  <style>
    body { font-family: monospace; padding: 20px; background: #222; color: #eee; }
    input, select, textarea, button { margin: 5px 0; padding: 6px; font-size: 14px; }
    label { display: block; margin-top: 10px; }
    textarea { width: 100%; height: 200px; white-space: pre; background: #111; color: #0f0; }
    .preview { background: #111; padding: 10px; margin-top: 10px; white-space: pre-wrap; border: 1px solid #444; }
    #buttonGroup { margin-top: 10px; display: flex; gap: 10px; }
  </style>
  <!-- Add gifuct-js CDN -->
  <script src="https://unpkg.com/gifuct-js/dist/gifuct.min.js"></script>
</head>
<body>
  <h2>Image to Command Generator</h2>

  <label>Upload Image:
    <input type="file" id="imgInput" accept="image/*" />
  </label>

  <label>Rows (max 14 for book mode): <input type="number" id="rows" value="14" min="1" max="64" /></label>
  <label>Pixels Per Row (max 12 for book mode): <input type="number" id="cols" value="12" min="1" max="64" /></label>
  <label>Font: <input type="text" id="font" value="minecraft:default" /></label>

  <label>Pixel Character(s):
    <select id="charSelect">
      <option value="█">█</option>
      <option value="■">■</option>
      <option value="custom">Custom...</option>
    </select>
    <input type="text" id="customChar" value="@" maxlength="2" style="display:none; margin-left: 10px;" />
  </label>

  <label>Output Mode:
    <select id="mode">
      <option value="raw">Raw</option>
      <option value="tellraw">Tellraw</option>
      <option value="book">Book</option>
      <option value="textdisplay">Text Display</option>
      <option value="scoreboard">Scoreboard</option>
      <option value="itemlore">Item Lore</option>
      <option value="gifbook">GIF Book</option>
    </select>
  </label>

  <div id="bookFields" style="display: none;">
    <label>Book Title: <input type="text" id="bookTitle" value="Pixel Image" /></label>
    <label>Book Author: <input type="text" id="bookAuthor" value="ImageTool" /></label>
  </div>

  <div id="scoreboardFields" style="display: none;">
    <label>Scoreboard Name: <input type="text" id="scoreboardName" value="pixelDisplay" /></label>
  </div>

  <div id="itemFields" style="display: none;">
    <label>Item ID: <input type="text" id="itemId" value="minecraft:stick" /></label>
  </div>

  <div id="buttonGroup">
    <button id="generateBtn">Generate JSON</button>
    <button id="saveBtn" disabled>Save MCFunction</button>
  </div>

  <h3>Output</h3>
  <textarea id="output" readonly></textarea>

  <h3>Preview</h3>
  <div class="preview" id="previewBox"></div>

  <canvas id="canvas" style="display:none;"></canvas>

<script>
document.getElementById("mode").addEventListener("change", function () {
  const mode = this.value;
  document.getElementById("bookFields").style.display = mode === "book" || mode === "gifbook" ? "block" : "none";
  document.getElementById("scoreboardFields").style.display = mode === "scoreboard" ? "block" : "none";
  document.getElementById("itemFields").style.display = mode === "itemlore" ? "block" : "none";
});

document.getElementById("charSelect").addEventListener("change", function () {
  const customCharInput = document.getElementById("customChar");
  customCharInput.style.display = this.value === "custom" ? "inline-block" : "none";
});

function getColorHex(r, g, b) {
  return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
}

function getSelectedChar() {
  const select = document.getElementById("charSelect");
  const value = select.value;
  if (value === "custom") {
    const custom = document.getElementById("customChar").value;
    return custom || "@";
  }
  return value;
}

function loadImageFromBlob(blob) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = e => {
      URL.revokeObjectURL(url);
      reject(e);
    };
    img.src = url;
  });
}

// Convert ImageData to grid of text/color objects
function imageDataToGrid(imageData, cols, rows, pixelChar, font) {
  const grid = [];
  const data = imageData.data;
  for (let y = 0; y < rows; y++) {
    const row = [];
    for (let x = 0; x < cols; x++) {
      const i = (y * cols + x) * 4;
      const r = data[i];
      const g = data[i + 1];
      const b = data[i + 2];
      const a = data[i + 3];
      if (a < 10) {
        row.push({ text: " ", color: "#000000", italic: false });
        continue;
      }
      const color = getColorHex(r, g, b);
      if (font === "minecraft:default") {
        row.push({ text: pixelChar, color, italic: false });
      } else {
        row.push({ font: font, text: pixelChar, color, italic: false });
      }
    }
    grid.push(row);
  }
  return grid;
}

// Convert grid to JSON page text array string for book pages
function gridToPageJson(grid) {
  const pageContent = [];
  grid.forEach(row => {
    row.forEach(px => {
      pageContent.push(px);
    });
    pageContent.push({ text: "\n" });
  });
  return JSON.stringify(pageContent);
}

async function processImage() {
  const file = document.getElementById("imgInput").files[0];
  if (!file) {
    alert("Please upload an image first.");
    return;
  }

  const rows = parseInt(document.getElementById("rows").value);
  const cols = parseInt(document.getElementById("cols").value);
  const pixelChar = getSelectedChar();
  const font = document.getElementById("font").value;
  const mode = document.getElementById("mode").value;
  const title = document.getElementById("bookTitle")?.value || "Pixel Image";
  const author = document.getElementById("bookAuthor")?.value || "ImageTool";
  const scoreboardName = document.getElementById("scoreboardName")?.value.trim();
  const itemId = document.getElementById("itemId")?.value || "minecraft:stick";

  if (mode === "scoreboard" && scoreboardName.length === 0) {
    alert("Please enter a scoreboard name.");
    return;
  }

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  document.getElementById("saveBtn").disabled = true;

  try {
    if (mode !== "gifbook") {
      // Single image modes

      const img = await loadImageFromBlob(file);
      canvas.width = cols;
      canvas.height = rows;
      ctx.clearRect(0, 0, cols, rows);
      ctx.drawImage(img, 0, 0, cols, rows);
      const imageData = ctx.getImageData(0, 0, cols, rows);
      const grid = imageDataToGrid(imageData, cols, rows, pixelChar, font);

      let output = "";
      let preview = "";

      if (mode === "raw") {
        output = JSON.stringify(grid, null, 2);
        preview = grid.map(row => row.map(px => px.text).join("")).join("\n");
      } else if (mode === "tellraw") {
        const components = grid.map(row => ({
          text: "\n",
          extra: row.map(px => ({
            text: px.text,
            color: px.color,
            font: px.font,
            italic: px.italic
          }))
        }));
        output = JSON.stringify([{ text: "", extra: components }], null, 2);
        preview = grid.map(row => row.map(px => px.text).join("")).join("\n");
      } else if (mode === "book") {
        // One page only
        const pageJson = gridToPageJson(grid);
        output = JSON.stringify({
          title,
          author,
          pages: [pageJson]
        }, null, 2);
        preview = grid.map(row => row.map(px => px.text).join("")).join("\n");
      } else if (mode === "textdisplay") {
        // Summon text_display entities, one per row
        const lines = [];
        for (let y = 0; y < grid.length; y++) {
          const line = grid[y].map(px => px.text).join("");
          lines.push(`/summon text_display ~ ~${y} ~ {text:'{"text":"${line}"}'}`);
        }
        output = lines.join("\n");
        preview = grid.map(row => row.map(px => px.text).join("")).join("\n");
      } else if (mode === "scoreboard") {
        // Summon armor_stand with scoreboard and text
        if (!scoreboardName) {
          alert("Please enter a scoreboard name.");
          return;
        }
        let commands = [];
        for (let y = 0; y < grid.length; y++) {
          const line = grid[y].map(px => px.text).join("");
          commands.push(`scoreboard players set @e[type=armor_stand,tag=Line${y}] ${scoreboardName} 1`);
          commands.push(`tellraw @a {"text":"${line}"}`);
        }
        output = commands.join("\n");
        preview = grid.map(row => row.map(px => px.text).join("")).join("\n");
      } else if (mode === "itemlore") {
        // Item lore lines as array of strings
        const loreLines = grid.map(row => row.map(px => px.text).join(""));
        output = JSON.stringify(loreLines, null, 2);
        preview = loreLines.join("\n");
      }

      document.getElementById("output").value = output;
      document.getElementById("previewBox").innerText = preview;
      document.getElementById("saveBtn").disabled = output.trim().length === 0;

    } else {
      // GIF Book Mode
      // Use gifuct-js to parse frames

      const arrayBuffer = await file.arrayBuffer();
      const gif = gifuct.parseGIF(arrayBuffer);
      const frames = gifuct.decompressFrames(gif, true);

      if (!frames.length) {
        alert("No frames found in the GIF.");
        document.getElementById("output").value = "";
        document.getElementById("previewBox").innerText = "";
        document.getElementById("saveBtn").disabled = true;
        return;
      }

      const pages = [];

      for (const frame of frames) {
        // Create ImageData from frame.patch (RGBA array)
        canvas.width = frame.dims.width;
        canvas.height = frame.dims.height;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const frameImageData = ctx.createImageData(frame.dims.width, frame.dims.height);
        frameImageData.data.set(frame.patch);
        ctx.putImageData(frameImageData, 0, 0);

        // Scale frame to desired cols/rows
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = cols;
        tempCanvas.height = rows;
        const tempCtx = tempCanvas.getContext("2d");
        tempCtx.clearRect(0, 0, cols, rows);
        tempCtx.drawImage(canvas, 0, 0, cols, rows);

        const imageData = tempCtx.getImageData(0, 0, cols, rows);
        const grid = imageDataToGrid(imageData, cols, rows, pixelChar, font);

        const pageJson = gridToPageJson(grid);
        pages.push(pageJson);
      }

      // Compose book JSON with all pages
      const bookObj = {
        title,
        author,
        pages
      };

      const output = JSON.stringify(bookObj, null, 2);
      document.getElementById("output").value = output;

      // Preview only first page for simplicity
      const firstPageGrid = JSON.parse(pages[0]);
      let preview = "";
      firstPageGrid.forEach(el => {
        if (el.text === "\n") preview += "\n";
        else preview += el.text || "";
      });
      document.getElementById("previewBox").innerText = preview;

      document.getElementById("saveBtn").disabled = false;
    }
  } catch (ex) {
    alert("Error processing image: " + ex.message);
    console.error(ex);
    document.getElementById("saveBtn").disabled = true;
  }
}

function saveMCFunction() {
  const output = document.getElementById("output").value;
  if (!output) return;

  const blob = new Blob([output], { type: "text/plain" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "output.mcfunction";
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

document.getElementById("generateBtn").addEventListener("click", processImage);
document.getElementById("saveBtn").addEventListener("click", saveMCFunction);
</script>
</body>
</html>
